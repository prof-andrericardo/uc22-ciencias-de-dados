# üìò UC22 ‚Äì Aula 3 ‚Äì Introdu√ß√£o ao Pandas e DataFrames

*(Vers√£o Alunos ‚Äì **expandida**, com explica√ß√µes e c√≥digos comentados)*

![CSV](https://img.shields.io/badge/Formato-CSV-orange?logo=file)
 ![Python](https://img.shields.io/badge/Python-3.11+-blue?logo=python)
 ![Pandas](https://img.shields.io/badge/Pandas-DataFrame-green?logo=pandas)
 ![Google Colab](https://img.shields.io/badge/Google%20Colab-Notebook-yellow?logo=googlecolab)
 ![Tempo](https://img.shields.io/badge/Dura%C3%A7%C3%A3o-90%20min-red)
 ![N√≠vel](https://img.shields.io/badge/N%C3%ADvel-Iniciante%E2%9E%9CIntermedi%C3%A1rio-purple)

üéì **Turma:** 3¬∫ Ano ‚Äì Ensino M√©dio T√©cnico em Inform√°tica
 üìç **Tema:** Pandas e o conceito de **DataFrame** (Pok√©mon + Escolas Estaduais)
 üêç **Ferramenta principal:** Google Colab

------

## ‚ú® Frase motivadora

> ‚ÄúVoc√™ n√£o precisa decorar c√≥digos; precisa entender o que os **dados** querem te contar.‚Äù ‚Äì IAra üí°

------

## üéØ Objetivos de Aprendizagem

- Entender, **com precis√£o**, o que s√£o **Pandas**, **DataFrame**, **Series**, **Index**, **tipos de dados (dtypes)** e **valores ausentes (NaN)**.
- Ler arquivos CSV de forma **segura e robusta** (encoding, separador, erros comuns).
- Explorar um DataFrame com `head`, `tail`, `sample`, `info`, `shape`, `dtypes`, `columns`.
- Fazer **primeiras an√°lises**: `describe`, `nunique`, `unique`, `value_counts`, contagem de nulos.
- Come√ßar a **padronizar** nomes de colunas (limpar espa√ßos, min√∫sculas).

------

## üß† Conceitos Essenciais (explicados de forma direta)

**Pandas**

- Biblioteca do Python focada em **an√°lise e manipula√ß√£o de dados**.
- Fornece estruturas poderosas para trabalhar com tabelas (como planilhas), mas **via c√≥digo**.

**DataFrame**

- √â a **tabela principal** do Pandas: linhas (registros) √ó colunas (atributos).
- Pense em uma planilha do Excel **dentro do Python**.
- Cada coluna de um DataFrame √© uma **Series**.

**Series**

- √â **uma coluna** (ou uma linha) do DataFrame, com um tipo de dado predominante.
- Ex.: coluna ‚ÄúHP‚Äù (inteiros), coluna ‚ÄúNome‚Äù (texto).

**Index (√çndice)**

- √â a **etiqueta** de cada linha. Por padr√£o, come√ßa em 0, 1, 2‚Ä¶
- Ajuda o Pandas a localizar e alinhar dados.

**dtypes (data types)**

- Tipos das colunas:
  - `int64` (inteiro), `float64` (decimal), `object` (texto), `bool`, `datetime64[ns]` (datas).
- Tipos corretos **evitam erros** e **aceleram an√°lises**.

**NaN / valores ausentes**

- Representam **dados faltantes**.
- Precisam ser detectados (ex.: `isna()`) e tratados mais adiante (preencher/excluir).

------

## üß∞ Preparando o Colab e subindo os arquivos

> Voc√™ vai precisar dos arquivos `pokemons.csv` **e** `escolas_estaduais_censo_escolar_2023.csv`.

```python
# Coment√°rios linha por linha para subir arquivos no Colab

from google.colab import files  # importa utilit√°rio do Colab para upload de arquivos

uploaded = files.upload()       # abre a janela para selecionar arquivos do seu computador
                                # escolha pokemons.csv e escolas_estaduais_censo_escolar_2023.csv
```

------

## 1) Importando o Pandas e conferindo a vers√£o

```python
# Importa a biblioteca Pandas e verifica a vers√£o instalada

import pandas as pd                 # 'pd' √© um apelido (alias) comum para Pandas
print(pd.__version__)               # imprime a vers√£o do Pandas (√∫til para compatibilidade)
pd.options.display.max_columns = 50 # (opcional) aumenta o limite de colunas mostradas ao imprimir tabelas
```

**Por que isso importa?**
 Algumas fun√ß√µes e mensagens mudam conforme a vers√£o. Saber a vers√£o ajuda a pesquisar solu√ß√µes corretas.

------

## 2) Lendo os CSVs de forma **robusta** (com encoding e separador)

> Dica: se **acentos** sa√≠rem estranhos (√É, √ï), troque `encoding`.
>  Se tudo vier em **uma coluna s√≥**, verifique o `sep` (separador).

```python
# Leitura robusta dos dois CSVs (Pok√©mon e Escolas) com coment√°rios detalhados

# ---------- Pok√©mon ----------
# Tenta ler com UTF-8 (padr√£o comum para dados p√∫blicos e arquivos modernos)
try:
    df_poke = pd.read_csv("pokemons.csv", encoding="utf-8")  # tenta UTF-8
except UnicodeDecodeError:
    df_poke = pd.read_csv("pokemons.csv", encoding="latin-1")# se der erro de acentua√ß√£o, usa latin-1
except FileNotFoundError:
    raise FileNotFoundError("Arquivo 'pokemons.csv' n√£o encontrado. Fa√ßa o upload no Colab.")

# Se veio tudo numa coluna s√≥, provavelmente o separador √© ';' (padr√£o PT-BR em alguns casos)
if df_poke.shape[1] == 1:                                     # se s√≥ tem 1 coluna...
    df_poke = pd.read_csv("pokemons.csv", encoding="utf-8", sep=";")  # tenta com separador ponto-e-v√≠rgula


# ---------- Escolas (Censo Escolar 2023) ----------
# Esse arquivo costuma usar codifica√ß√£o 'latin-1' por causa de acentos em PT-BR
try:
    df_escolas = pd.read_csv("escolas_estaduais_censo_escolar_2023.csv", encoding="latin-1")
except UnicodeDecodeError:
    df_escolas = pd.read_csv("escolas_estaduais_censo_escolar_2023.csv", encoding="utf-8")
except FileNotFoundError:
    raise FileNotFoundError("Arquivo 'escolas_estaduais_censo_escolar_2023.csv' n√£o encontrado. Fa√ßa o upload no Colab.")

# Confer√™ncia do separador para o arquivo de escolas (caso venha tudo numa coluna s√≥)
if df_escolas.shape[1] == 1:
    df_escolas = pd.read_csv("escolas_estaduais_censo_escolar_2023.csv", encoding="latin-1", sep=";")
```

**Como saber se deu certo?**

- Se o n√∫mero de **colunas** fizer sentido (mais que 1), est√° ok.
- Se os **acentos** aparecerem corretamente, o `encoding` est√° correto.

------

## 3) DataFrame na pr√°tica: primeiras inspe√ß√µes

```python
# Visualiza√ß√£o inicial dos dados (primeiras e √∫ltimas linhas, amostras aleat√≥rias)

df_poke.head()           # mostra as 5 primeiras linhas do dataset Pok√©mon
df_poke.tail()           # mostra as 5 √∫ltimas linhas

df_escolas.head()        # mostra as 5 primeiras linhas do dataset Escolas
df_escolas.tail()        # mostra as 5 √∫ltimas linhas

df_poke.sample(5)        # mostra 5 linhas aleat√≥rias do Pok√©mon
df_escolas.sample(5)     # mostra 5 linhas aleat√≥rias das Escolas
```

**Por que usar `head/tail/sample`?**

- Evita rolar uma tabela gigante.
- D√° uma vis√£o r√°pida de **como** os dados est√£o.

------

## 4) Estrutura do DataFrame: `shape`, `columns`, `index`, `dtypes`, `info`

```python
# Entendendo a estrutura: dimens√µes, nomes de colunas, √≠ndice e tipos de dados

print("POK√âMON:", df_poke.shape)        # (n_linhas, n_colunas) do Pok√©mon
print("ESCOLAS:", df_escolas.shape)     # (n_linhas, n_colunas) das Escolas

print(df_poke.columns)                  # lista com os nomes das colunas do Pok√©mon
print(df_escolas.columns)               # lista com os nomes das colunas das Escolas

print(df_poke.index)                    # mostra o √≠ndice (r√≥tulos das linhas) do Pok√©mon
print(df_escolas.index)                 # mostra o √≠ndice das Escolas

print(df_poke.dtypes)                   # tipos de dados por coluna no Pok√©mon
print(df_escolas.dtypes)                # tipos de dados por coluna nas Escolas

df_poke.info()                          # resumo: colunas, n√£o-nulos, dtypes (Pok√©mon)
df_escolas.info()                       # resumo: colunas, n√£o-nulos, dtypes (Escolas)
```

**Leitura desses resultados:**

- `shape`: ‚Äúquantidade de **linhas** √ó **colunas**‚Äù.
- `columns`: garante os **nomes exatos** (evita erro por digitar diferente).
- `dtypes`/`info`: mostra tipos; se algo deveria ser n√∫mero mas est√° como `object`, vamos corrigir mais tarde.

------

## 5) Lidando com **valores ausentes (NaN)** e nulos

```python
# Detec√ß√£o de valores ausentes (NaN) por coluna e porcentagem de nulos

# ---- Pok√©mon ----
nulos_poke = df_poke.isna().sum()                          # conta quantos NaN existem em cada coluna
perc_nulos_poke = (nulos_poke / len(df_poke)) * 100        # calcula a porcentagem de nulos por coluna
print("Nulos (Pok√©mon):")
print(pd.DataFrame({"nulos": nulos_poke, "perc_%": perc_nulos_poke.round(2)}))

# ---- Escolas ----
nulos_escolas = df_escolas.isna().sum()
perc_nulos_escolas = (nulos_escolas / len(df_escolas)) * 100
print("Nulos (Escolas):")
print(pd.DataFrame({"nulos": nulos_escolas, "perc_%": perc_nulos_escolas.round(2)}))
```

**Por que isso importa?**

- Antes de analisar de verdade, precisamos saber **o que est√° faltando**.
- Depois voc√™ decide: **preencher**? **excluir**? **deixar como est√°**?

------

## 6) **Sum√°rios** e estat√≠sticas r√°pidas

```python
# Estat√≠sticas descritivas para colunas num√©ricas e de texto

# ---- Pok√©mon ----
print(df_poke.describe())                          # estat√≠sticas num√©ricas (m√©dia, desvio, min, max, quartis)
print(df_poke.describe(include='object'))          # estat√≠sticas para texto (contagem, valores √∫nicos, topo, freq)

# ---- Escolas ----
print(df_escolas.describe())                       # num√©ricas
print(df_escolas.describe(include='object'))       # texto/categ√≥ricas
```

**Dica:** `describe(include='object')` √© √≥timo para ‚Äúver‚Äù colunas de texto (quantos valores √∫nicos, qual aparece mais).

------

## 7) **Valores √∫nicos** e contagens por categoria (sem depender de nomes)

> √Äs vezes voc√™ **n√£o sabe** qual coluna usar. Vamos achar **automaticamente** a primeira coluna textual e contar as categorias.

```python
# Identifica uma coluna categ√≥rica (de texto) automaticamente e mostra as top categorias

# ---- Pok√©mon ----
cat_cols_poke = df_poke.select_dtypes(include='object').columns    # pega nomes de colunas com tipo texto
if len(cat_cols_poke) > 0:                                         # se existir ao menos uma...
    colp = cat_cols_poke[0]                                        # escolhe a primeira coluna de texto
    print("Coluna categ√≥rica escolhida (Pok√©mon):", colp)
    print(df_poke[colp].value_counts().head(10))                   # top 10 categorias mais frequentes
else:
    print("N√£o h√° colunas categ√≥ricas de texto no Pok√©mon.")

# ---- Escolas ----
cat_cols_escolas = df_escolas.select_dtypes(include='object').columns
if len(cat_cols_escolas) > 0:
    cole = cat_cols_escolas[0]
    print("Coluna categ√≥rica escolhida (Escolas):", cole)
    print(df_escolas[cole].value_counts().head(10))
else:
    print("N√£o h√° colunas categ√≥ricas de texto em Escolas.")
```

> **Se voc√™ j√° souber** o nome da coluna (ex.: `NO_MUNICIPIO`), use diretamente:
>
> ```python
> df_escolas['NO_MUNICIPIO'].value_counts().head(10)
> ```

------

## 8) **Padroniza√ß√£o inicial** (nomes de colunas e textos)

> Padronizar cedo evita dor de cabe√ßa: nomes com espa√ßos, acentos e mai√∫sculas misturadas atrapalham.

```python
# Limpeza e padroniza√ß√£o leve: nomes de colunas e alguns textos

# ---- Pok√©mon ----
df_poke.columns = (df_poke.columns
                   .str.strip()          # remove espa√ßos no come√ßo/fim
                   .str.lower()          # tudo min√∫sculo
                   .str.replace(' ', '_', regex=False)  # troca espa√ßo por _
                  )

# Se existir uma coluna de "tipo", melhora consist√™ncia (exemplo gen√©rico)
if 'tipo' in df_poke.columns:
    df_poke['tipo'] = df_poke['tipo'].astype(str).str.strip().str.lower()

# ---- Escolas ----
df_escolas.columns = (df_escolas.columns
                      .str.strip()
                      .str.lower()
                      .str.replace(' ', '_', regex=False))

# Exemplo: se "no_municipio" existir, padroniza
if 'no_municipio' in df_escolas.columns:
    df_escolas['no_municipio'] = df_escolas['no_municipio'].astype(str).str.strip().str.title()  # T√≠tulo: "S√£o Paulo"
```

**Por que isso importa?**

- Facilita digita√ß√£o (`no_municipio` √© melhor que `NO MUNICIPIO`).
- Evita bugs em filtros e jun√ß√µes no futuro.

------

## 9) **Convertendo tipos** (quando n√∫meros v√™m como texto)

> Alguns CSVs trazem n√∫meros com v√≠rgula decimal ou como texto. Vamos converter com seguran√ßa.

```python
# Convers√£o segura de colunas num√©ricas que vieram como texto (exemplo gen√©rico)

import numpy as np  # biblioteca para trabalhar com n√∫meros (NaN, arrays etc.)

# Fun√ß√£o auxiliar: tenta converter uma coluna para n√∫mero, considerando v√≠rgula como decimal
def to_numeric_safe(s):
    s = s.astype(str).str.replace('.', '', regex=False)   # remove separador de milhar (.)
    s = s.str.replace(',', '.', regex=False)              # troca v√≠rgula decimal por ponto
    return pd.to_numeric(s, errors='coerce')              # converte; valores inv√°lidos viram NaN

# Exemplo de aplica√ß√£o gen√©rica (apenas se voc√™ souber quais colunas s√£o n√∫meros):
# Substitua 'coluna_que_deveria_ser_numero' pelo nome real da sua coluna
possible_numeric_cols = []  # preencha com colunas que voc√™ identificar como num√©ricas

for col in possible_numeric_cols:
    if col in df_escolas.columns:
        df_escolas[col] = to_numeric_safe(df_escolas[col])  # aplica convers√£o segura
```

**Dica:**
 Use `df.dtypes` antes/depois para confirmar a convers√£o.

------

## 10) Checklist r√°pido (o que voc√™ j√° sabe fazer)

-  Ler CSV com `read_csv`, ajustando `encoding`/`sep`.
-  Inspecionar **linhas** com `head`, `tail`, `sample`.
-  Ver **estrutura** com `shape`, `columns`, `index`, `dtypes`, `info`.
-  Detectar **nulos**: `isna().sum()` e porcentagem.
-  Fazer **sum√°rios** com `describe`.
-  Contar **categorias** com `value_counts`.
-  **Padronizar** nomes de colunas e textos.

------

## üß™ Mini-Lab (para entregar no Colab)

1. Mostre:

- As **primeiras 5** e as **√∫ltimas 5** linhas de **cada** dataset.
- O **tamanho** (linhas x colunas) de cada dataset.
- A **lista de colunas** e os **tipos de dados**.

1. Conte:

- **Nulos por coluna** e a **porcentagem** de nulos (tabela).
- Para **uma coluna categ√≥rica** de sua escolha, mostre as **10 categorias mais frequentes** com `value_counts()`.

1. Padronize:

- Nomes de colunas (min√∫sculas, sem espa√ßos).
- Uma coluna de texto relevante (ex.: munic√≠pio ‚Üí `Title Case`).

> **Nome do arquivo**: `UC22_Aula03_Pratica_SeuNome.ipynb` (subir no Classroom)

------

## üßØ Erros comuns e solu√ß√µes r√°pidas

- **‚ÄúUnicodeDecodeError‚Äù** ‚Üí troque `encoding` entre `"utf-8"` e `"latin-1"`.
- **‚ÄúTudo numa coluna s√≥‚Äù** ‚Üí defina `sep=";"` (ou `sep=","`, conforme o arquivo).
- **N√∫meros como texto** ‚Üí use convers√£o (ver se√ß√£o 9).
- **Nome de coluna n√£o encontrado** ‚Üí confirme com `df.columns` e **copie/cole** o nome exato.

------

## üìå O que vem na pr√≥xima aula

Vamos aprender a **selecionar colunas e aplicar filtros** para responder perguntas do tipo:

- ‚ÄúTop 10 Pok√©mons por Ataque‚Äù
- ‚ÄúMunic√≠pios com mais escolas estaduais‚Äù
- ‚ÄúQuantas escolas por depend√™ncia administrativa?‚Äù

------

## üìö Gloss√°rio r√°pido

- **Pandas**: biblioteca para an√°lise de dados em Python.
- **DataFrame**: tabela (linhas x colunas).
- **Series**: uma √∫nica coluna (ou linha) do DataFrame.
- **Index**: r√≥tulos das linhas.
- **dtype**: tipo de dado (int, float, object‚Ä¶).
- **NaN**: valor ausente (faltando).
- **Encoding**: regra de acentua√ß√£o/car√°teres no arquivo (UTF-8, Latin-1).
- **Separador (sep)**: caractere que separa as colunas no CSV (`,` ou `;`).

------

