# ğŸ“˜ UC22 â€“ Aula 3 â€“ IntroduÃ§Ã£o ao Pandas e DataFrames

*(VersÃ£o Alunos â€“ **expandida**, com explicaÃ§Ãµes e cÃ³digos comentados)*

![CSV](https://img.shields.io/badge/Formato-CSV-orange?logo=file)
 ![Python](https://img.shields.io/badge/Python-3.11+-blue?logo=python)
 ![Pandas](https://img.shields.io/badge/Pandas-DataFrame-green?logo=pandas)
 ![Google Colab](https://img.shields.io/badge/Google%20Colab-Notebook-yellow?logo=googlecolab)
 ![Tempo](https://img.shields.io/badge/Dura%C3%A7%C3%A3o-90%20min-red)
 ![NÃ­vel](https://img.shields.io/badge/N%C3%ADvel-Iniciante%E2%9E%9CIntermedi%C3%A1rio-purple)

ğŸ“ **Turma:** 3Âº Ano â€“ Ensino MÃ©dio TÃ©cnico em InformÃ¡tica
 ğŸ“ **Tema:** Pandas e o conceito de **DataFrame** (PokÃ©mon + Escolas Estaduais)
 ğŸ **Ferramenta principal:** Google Colab

------

## âœ¨ Frase motivadora

> â€œVocÃª nÃ£o precisa decorar cÃ³digos; precisa entender o que os **dados** querem te contar.â€ â€“ IAra ğŸ’¡

------

## ğŸ¯ Objetivos de Aprendizagem

- Entender, **com precisÃ£o**, o que sÃ£o **Pandas**, **DataFrame**, **Series**, **Index**, **tipos de dados (dtypes)** e **valores ausentes (NaN)**.
- Ler arquivos CSV de forma **segura e robusta** (encoding, separador, erros comuns).
- Explorar um DataFrame com `head`, `tail`, `sample`, `info`, `shape`, `dtypes`, `columns`.
- Fazer **primeiras anÃ¡lises**: `describe`, `nunique`, `unique`, `value_counts`, contagem de nulos.
- ComeÃ§ar a **padronizar** nomes de colunas (limpar espaÃ§os, minÃºsculas).

------

## ğŸ§  Conceitos Essenciais (explicados de forma direta)

**Pandas**

- Biblioteca do Python focada em **anÃ¡lise e manipulaÃ§Ã£o de dados**.
- Fornece estruturas poderosas para trabalhar com tabelas (como planilhas), mas **via cÃ³digo**.

**DataFrame**

- Ã‰ a **tabela principal** do Pandas: linhas (registros) Ã— colunas (atributos).
- Pense em uma planilha do Excel **dentro do Python**.
- Cada coluna de um DataFrame Ã© uma **Series**.

**Series**

- Ã‰ **uma coluna** (ou uma linha) do DataFrame, com um tipo de dado predominante.
- Ex.: coluna â€œHPâ€ (inteiros), coluna â€œNomeâ€ (texto).

**Index (Ãndice)**

- Ã‰ a **etiqueta** de cada linha. Por padrÃ£o, comeÃ§a em 0, 1, 2â€¦
- Ajuda o Pandas a localizar e alinhar dados.

**dtypes (data types)**

- Tipos das colunas:
  - `int64` (inteiro), `float64` (decimal), `object` (texto), `bool`, `datetime64[ns]` (datas).
- Tipos corretos **evitam erros** e **aceleram anÃ¡lises**.

**NaN / valores ausentes**

- Representam **dados faltantes**.
- Precisam ser detectados (ex.: `isna()`) e tratados mais adiante (preencher/excluir).

------

## ğŸ§° Preparando o Colab e subindo os arquivos

> VocÃª vai precisar dos arquivos `pokemons.csv` **e** `escolas_estaduais_censo_escolar_2023.csv`.

```python
# ComentÃ¡rios linha por linha para subir arquivos no Colab

from google.colab import files  # importa utilitÃ¡rio do Colab para upload de arquivos

uploaded = files.upload()       # abre a janela para selecionar arquivos do seu computador
                                # escolha pokemons.csv e escolas_estaduais_censo_escolar_2023.csv
```

------

## 1) Importando o Pandas e conferindo a versÃ£o

```python
# Importa a biblioteca Pandas e verifica a versÃ£o instalada

import pandas as pd                 # 'pd' Ã© um apelido (alias) comum para Pandas
print(pd.__version__)               # imprime a versÃ£o do Pandas (Ãºtil para compatibilidade)
pd.options.display.max_columns = 50 # (opcional) aumenta o limite de colunas mostradas ao imprimir tabelas
```

**Por que isso importa?**
 Algumas funÃ§Ãµes e mensagens mudam conforme a versÃ£o. Saber a versÃ£o ajuda a pesquisar soluÃ§Ãµes corretas.

------

## 2) Lendo os CSVs de forma **robusta** (com encoding e separador)

> Dica: se **acentos** saÃ­rem estranhos (Ãƒ, Ã•), troque `encoding`.
>  Se tudo vier em **uma coluna sÃ³**, verifique o `sep` (separador).

```python
# Leitura robusta dos dois CSVs (PokÃ©mon e Escolas) com comentÃ¡rios detalhados

# ---------- PokÃ©mon ----------
# Tenta ler com UTF-8 (padrÃ£o comum para dados pÃºblicos e arquivos modernos)
try:
    df_poke = pd.read_csv("pokemons.csv", encoding="utf-8")  # tenta UTF-8
except UnicodeDecodeError:
    df_poke = pd.read_csv("pokemons.csv", encoding="latin-1")# se der erro de acentuaÃ§Ã£o, usa latin-1
except FileNotFoundError:
    raise FileNotFoundError("Arquivo 'pokemons.csv' nÃ£o encontrado. FaÃ§a o upload no Colab.")

# Se veio tudo numa coluna sÃ³, provavelmente o separador Ã© ';' (padrÃ£o PT-BR em alguns casos)
if df_poke.shape[1] == 1:                                     # se sÃ³ tem 1 coluna...
    df_poke = pd.read_csv("pokemons.csv", encoding="utf-8", sep=";")  # tenta com separador ponto-e-vÃ­rgula


# ---------- Escolas (Censo Escolar 2023) ----------
# Esse arquivo costuma usar codificaÃ§Ã£o 'latin-1' por causa de acentos em PT-BR
try:
    df_escolas = pd.read_csv("escolas_estaduais_censo_escolar_2023.csv", encoding="latin-1")
except UnicodeDecodeError:
    df_escolas = pd.read_csv("escolas_estaduais_censo_escolar_2023.csv", encoding="utf-8")
except FileNotFoundError:
    raise FileNotFoundError("Arquivo 'escolas_estaduais_censo_escolar_2023.csv' nÃ£o encontrado. FaÃ§a o upload no Colab.")

# ConferÃªncia do separador para o arquivo de escolas (caso venha tudo numa coluna sÃ³)
if df_escolas.shape[1] == 1:
    df_escolas = pd.read_csv("escolas_estaduais_censo_escolar_2023.csv", encoding="latin-1", sep=";")
```

**Como saber se deu certo?**

- Se o nÃºmero de **colunas** fizer sentido (mais que 1), estÃ¡ ok.
- Se os **acentos** aparecerem corretamente, o `encoding` estÃ¡ correto.

------

## 3) DataFrame na prÃ¡tica: primeiras inspeÃ§Ãµes

```python
# VisualizaÃ§Ã£o inicial dos dados (primeiras e Ãºltimas linhas, amostras aleatÃ³rias)

df_poke.head()           # mostra as 5 primeiras linhas do dataset PokÃ©mon
df_poke.tail()           # mostra as 5 Ãºltimas linhas

df_escolas.head()        # mostra as 5 primeiras linhas do dataset Escolas
df_escolas.tail()        # mostra as 5 Ãºltimas linhas

df_poke.sample(5)        # mostra 5 linhas aleatÃ³rias do PokÃ©mon
df_escolas.sample(5)     # mostra 5 linhas aleatÃ³rias das Escolas
```

**Por que usar `head/tail/sample`?**

- Evita rolar uma tabela gigante.
- DÃ¡ uma visÃ£o rÃ¡pida de **como** os dados estÃ£o.

------

## 4) Estrutura do DataFrame: `shape`, `columns`, `index`, `dtypes`, `info`

```python
# Entendendo a estrutura: dimensÃµes, nomes de colunas, Ã­ndice e tipos de dados

print("POKÃ‰MON:", df_poke.shape)        # (n_linhas, n_colunas) do PokÃ©mon
print("ESCOLAS:", df_escolas.shape)     # (n_linhas, n_colunas) das Escolas

print(df_poke.columns)                  # lista com os nomes das colunas do PokÃ©mon
print(df_escolas.columns)               # lista com os nomes das colunas das Escolas

print(df_poke.index)                    # mostra o Ã­ndice (rÃ³tulos das linhas) do PokÃ©mon
print(df_escolas.index)                 # mostra o Ã­ndice das Escolas

print(df_poke.dtypes)                   # tipos de dados por coluna no PokÃ©mon
print(df_escolas.dtypes)                # tipos de dados por coluna nas Escolas

df_poke.info()                          # resumo: colunas, nÃ£o-nulos, dtypes (PokÃ©mon)
df_escolas.info()                       # resumo: colunas, nÃ£o-nulos, dtypes (Escolas)
```

**Leitura desses resultados:**

- `shape`: â€œquantidade de **linhas** Ã— **colunas**â€.
- `columns`: garante os **nomes exatos** (evita erro por digitar diferente).
- `dtypes`/`info`: mostra tipos; se algo deveria ser nÃºmero mas estÃ¡ como `object`, vamos corrigir mais tarde.

------

## 5) Lidando com **valores ausentes (NaN)** e nulos

```python
# DetecÃ§Ã£o de valores ausentes (NaN) por coluna e porcentagem de nulos

# ---- PokÃ©mon ----
nulos_poke = df_poke.isna().sum()                          # conta quantos NaN existem em cada coluna
perc_nulos_poke = (nulos_poke / len(df_poke)) * 100        # calcula a porcentagem de nulos por coluna
print("Nulos (PokÃ©mon):")
print(pd.DataFrame({"nulos": nulos_poke, "perc_%": perc_nulos_poke.round(2)}))

# ---- Escolas ----
nulos_escolas = df_escolas.isna().sum()
perc_nulos_escolas = (nulos_escolas / len(df_escolas)) * 100
print("Nulos (Escolas):")
print(pd.DataFrame({"nulos": nulos_escolas, "perc_%": perc_nulos_escolas.round(2)}))
```

**Por que isso importa?**

- Antes de analisar de verdade, precisamos saber **o que estÃ¡ faltando**.
- Depois vocÃª decide: **preencher**? **excluir**? **deixar como estÃ¡**?

------

## 6) **SumÃ¡rios** e estatÃ­sticas rÃ¡pidas

```python
# EstatÃ­sticas descritivas para colunas numÃ©ricas e de texto

# ---- PokÃ©mon ----
print(df_poke.describe())                          # estatÃ­sticas numÃ©ricas (mÃ©dia, desvio, min, max, quartis)
print(df_poke.describe(include='object'))          # estatÃ­sticas para texto (contagem, valores Ãºnicos, topo, freq)

# ---- Escolas ----
print(df_escolas.describe())                       # numÃ©ricas
print(df_escolas.describe(include='object'))       # texto/categÃ³ricas
```

**Dica:** `describe(include='object')` Ã© Ã³timo para â€œverâ€ colunas de texto (quantos valores Ãºnicos, qual aparece mais).

------

## 7) **Valores Ãºnicos** e contagens por categoria (sem depender de nomes)

> Ã€s vezes vocÃª **nÃ£o sabe** qual coluna usar. Vamos achar **automaticamente** a primeira coluna textual e contar as categorias.

```python
# Identifica uma coluna categÃ³rica (de texto) automaticamente e mostra as top categorias

# ---- PokÃ©mon ----
cat_cols_poke = df_poke.select_dtypes(include='object').columns    # pega nomes de colunas com tipo texto
if len(cat_cols_poke) > 0:                                         # se existir ao menos uma...
    colp = cat_cols_poke[0]                                        # escolhe a primeira coluna de texto
    print("Coluna categÃ³rica escolhida (PokÃ©mon):", colp)
    print(df_poke[colp].value_counts().head(10))                   # top 10 categorias mais frequentes
else:
    print("NÃ£o hÃ¡ colunas categÃ³ricas de texto no PokÃ©mon.")

# ---- Escolas ----
cat_cols_escolas = df_escolas.select_dtypes(include='object').columns
if len(cat_cols_escolas) > 0:
    cole = cat_cols_escolas[0]
    print("Coluna categÃ³rica escolhida (Escolas):", cole)
    print(df_escolas[cole].value_counts().head(10))
else:
    print("NÃ£o hÃ¡ colunas categÃ³ricas de texto em Escolas.")
```

> **Se vocÃª jÃ¡ souber** o nome da coluna (ex.: `NO_MUNICIPIO`), use diretamente:
>
> ```python
> df_escolas['NO_MUNICIPIO'].value_counts().head(10)
> ```

------

## 8) **PadronizaÃ§Ã£o inicial** (nomes de colunas e textos)

> Padronizar cedo evita dor de cabeÃ§a: nomes com espaÃ§os, acentos e maiÃºsculas misturadas atrapalham.

```python
# Limpeza e padronizaÃ§Ã£o leve: nomes de colunas e alguns textos

# ---- PokÃ©mon ----
df_poke.columns = (df_poke.columns
                   .str.strip()          # remove espaÃ§os no comeÃ§o/fim
                   .str.lower()          # tudo minÃºsculo
                   .str.replace(' ', '_', regex=False)  # troca espaÃ§o por _
                  )

# Se existir uma coluna de "tipo", melhora consistÃªncia (exemplo genÃ©rico)
if 'tipo' in df_poke.columns:
    df_poke['tipo'] = df_poke['tipo'].astype(str).str.strip().str.lower()

# ---- Escolas ----
df_escolas.columns = (df_escolas.columns
                      .str.strip()
                      .str.lower()
                      .str.replace(' ', '_', regex=False))

# Exemplo: se "no_municipio" existir, padroniza
if 'no_municipio' in df_escolas.columns:
    df_escolas['no_municipio'] = df_escolas['no_municipio'].astype(str).str.strip().str.title()  # TÃ­tulo: "SÃ£o Paulo"
```

**Por que isso importa?**

- Facilita digitaÃ§Ã£o (`no_municipio` Ã© melhor que `NO MUNICIPIO`).
- Evita bugs em filtros e junÃ§Ãµes no futuro.

------

## 9) **Convertendo tipos** (quando nÃºmeros vÃªm como texto)

> Alguns CSVs trazem nÃºmeros com vÃ­rgula decimal ou como texto. Vamos converter com seguranÃ§a.

```python
# ConversÃ£o segura de colunas numÃ©ricas que vieram como texto (exemplo genÃ©rico)

import numpy as np  # biblioteca para trabalhar com nÃºmeros (NaN, arrays etc.)

# FunÃ§Ã£o auxiliar: tenta converter uma coluna para nÃºmero, considerando vÃ­rgula como decimal
def to_numeric_safe(s):
    s = s.astype(str).str.replace('.', '', regex=False)   # remove separador de milhar (.)
    s = s.str.replace(',', '.', regex=False)              # troca vÃ­rgula decimal por ponto
    return pd.to_numeric(s, errors='coerce')              # converte; valores invÃ¡lidos viram NaN

# Exemplo de aplicaÃ§Ã£o genÃ©rica (apenas se vocÃª souber quais colunas sÃ£o nÃºmeros):
# Substitua 'coluna_que_deveria_ser_numero' pelo nome real da sua coluna
possible_numeric_cols = []  # preencha com colunas que vocÃª identificar como numÃ©ricas

for col in possible_numeric_cols:
    if col in df_escolas.columns:
        df_escolas[col] = to_numeric_safe(df_escolas[col])  # aplica conversÃ£o segura
```

**Dica:**
 Use `df.dtypes` antes/depois para confirmar a conversÃ£o.

------

## 10) Checklist rÃ¡pido (o que vocÃª jÃ¡ sabe fazer)

-  Ler CSV com `read_csv`, ajustando `encoding`/`sep`.
-  Inspecionar **linhas** com `head`, `tail`, `sample`.
-  Ver **estrutura** com `shape`, `columns`, `index`, `dtypes`, `info`.
-  Detectar **nulos**: `isna().sum()` e porcentagem.
-  Fazer **sumÃ¡rios** com `describe`.
-  Contar **categorias** com `value_counts`.
-  **Padronizar** nomes de colunas e textos.

------

## ğŸ§ª Mini-Lab (para entregar no Colab)

1. Mostre:

- As **primeiras 5** e as **Ãºltimas 5** linhas de **cada** dataset.
- O **tamanho** (linhas x colunas) de cada dataset.
- A **lista de colunas** e os **tipos de dados**.

1. Conte:

- **Nulos por coluna** e a **porcentagem** de nulos (tabela).
- Para **uma coluna categÃ³rica** de sua escolha, mostre as **10 categorias mais frequentes** com `value_counts()`.

1. Padronize:

- Nomes de colunas (minÃºsculas, sem espaÃ§os).
- Uma coluna de texto relevante (ex.: municÃ­pio â†’ `Title Case`).

> **Nome do arquivo**: `UC22_Aula03_Pratica_SeuNome.ipynb` (subir no Classroom)

------

## ğŸ§¯ Erros comuns e soluÃ§Ãµes rÃ¡pidas

- **â€œUnicodeDecodeErrorâ€** â†’ troque `encoding` entre `"utf-8"` e `"latin-1"`.
- **â€œTudo numa coluna sÃ³â€** â†’ defina `sep=";"` (ou `sep=","`, conforme o arquivo).
- **NÃºmeros como texto** â†’ use conversÃ£o (ver seÃ§Ã£o 9).
- **Nome de coluna nÃ£o encontrado** â†’ confirme com `df.columns` e **copie/cole** o nome exato.

------

## ğŸ“Œ O que vem na prÃ³xima aula

Vamos aprender a **selecionar colunas e aplicar filtros** para responder perguntas do tipo:

- â€œTop 10 PokÃ©mons por Ataqueâ€
- â€œMunicÃ­pios com mais escolas estaduaisâ€
- â€œQuantas escolas por dependÃªncia administrativa?â€

------

## ğŸ“š GlossÃ¡rio rÃ¡pido

- **Pandas**: biblioteca para anÃ¡lise de dados em Python.
- **DataFrame**: tabela (linhas x colunas).
- **Series**: uma Ãºnica coluna (ou linha) do DataFrame.
- **Index**: rÃ³tulos das linhas.
- **dtype**: tipo de dado (int, float, objectâ€¦).
- **NaN**: valor ausente (faltando).
- **Encoding**: regra de acentuaÃ§Ã£o/carÃ¡teres no arquivo (UTF-8, Latin-1).
- **Separador (sep)**: caractere que separa as colunas no CSV (`,` ou `;`).

------

