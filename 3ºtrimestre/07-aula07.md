# ğŸ“˜ UC22 â€“ Aula 7 â€” Agrupamentos com `groupby()` (Pandas)

![Python](https://img.shields.io/badge/Python-3.11+-blue?logo=python)
![Pandas](https://img.shields.io/badge/Pandas-groupby-green?logo=pandas)
![Google Colab](https://img.shields.io/badge/Google%20Colab-Notebook-yellow?logo=googlecolab)
![Tempo](https://img.shields.io/badge/Dura%C3%A7%C3%A3o-90%20min-red)
![N%C3%ADvel](https://img.shields.io/badge/N%C3%ADvel-Iniciante%E2%9E%9CIntermedi%C3%A1rio-purple)

ğŸ“ **Turma:** 3Âº Ano â€“ Ensino MÃ©dio TÃ©cnico em InformÃ¡tica
ğŸ“ **Tema:** Agrupamentos e estatÃ­sticas por grupo com `groupby()`
ğŸ **Ferramenta principal:** Google Colab

---

## âœ¨ Frase motivadora

> â€œAgrupar Ã© comparar com contexto: sÃ³ entendemos um valor quando olhamos o **grupo** ao redor.â€ â€“ IAra ğŸ§ 

---

## ğŸ¯ Objetivos de Aprendizagem

Ao final desta aula, vocÃª serÃ¡ capaz de:

- Usar `groupby()` para **agrupar por uma ou mais colunas**.
- Calcular **estatÃ­sticas** por grupo: `count`, `mean`, `sum`, `min`, `max`, `median`, `std`.
- Aplicar **agregaÃ§Ãµes mÃºltiplas** com `.agg({...})`.
- **Ordenar** e **formatar** resultados de agrupamentos.
- Criar **ranking por grupo** (top-N) com `nlargest`, `sort_values` e mÃ¡scaras.
- (Opcional) **Gerar grÃ¡ficos** a partir de resultados agregados.

---

## ğŸ“‚ PreparaÃ§Ã£o (Google Drive)

Usaremos os mesmos arquivos:

- `pokemons_pokedex.csv`
- `escolas_estaduais_censo_escolar_2023.csv`

```python
# ğŸ“‚ Conectando o Google Drive
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

# Caminhos (ajuste conforme sua pasta no Drive)
caminho_poke = "/content/drive/MyDrive/UC22/pokemons_pokedex.csv"
caminho_escolas = "/content/drive/MyDrive/UC22/escolas_estaduais_censo_escolar_2023.csv"

# Leitura
df_poke = pd.read_csv(caminho_poke, encoding="utf-8")
df_escolas = pd.read_csv(caminho_escolas, encoding="latin-1", sep=",")

# PadronizaÃ§Ã£o de colunas
df_poke.columns    = df_poke.columns.str.strip().str.lower().str.replace(" ", "_", regex=False)
df_escolas.columns = df_escolas.columns.str.strip().str.lower().str.replace(" ", "_", regex=False)

# Ajuste opcional (texto)
if "no_municipio" in df_escolas.columns:
    df_escolas["no_municipio"] = df_escolas["no_municipio"].astype(str).str.strip().str.upper()

print("âœ… PokÃ©mon:", df_poke.shape, "colunas:", len(df_poke.columns))
print("âœ… Escolas:", df_escolas.shape, "colunas:", len(df_escolas.columns))
```

---

## 1) O que Ã© `groupby()`?

`groupby()` agrupa linhas que tÃªm o **mesmo valor** em uma (ou mais) colunas e permite calcular **estatÃ­sticas por grupo**.

- Ex.: mÃ©dia de `attack` por `type_1`;
- contagem de escolas por `no_municipio`;
- soma de HP por tipo; etc.

### Exemplo bÃ¡sico â€” mÃ©dia por tipo

```python
# ğŸ¯ MÃ©dia de atributos por type_1 (PokÃ©mon)
media_por_tipo = df_poke.groupby('type_1')[['attack','defense','speed','hp']].mean().round(2)
media_por_tipo.head(10)
```

---

## 2) FunÃ§Ãµes de agregaÃ§Ã£o comuns

- `count()` â€“ quantidade
- `mean()` â€“ mÃ©dia
- `sum()` â€“ soma
- `min()` / `max()` â€“ menor/maior
- `median()` â€“ mediana
- `std()` â€“ desvio padrÃ£o

### Exemplo â€” vÃ¡rias mÃ©tricas

```python
agr = df_poke.groupby('type_1').agg(
    qtd=('name', 'count'),
    media_atk=('attack', 'mean'),
    media_def=('defense', 'mean'),
    media_spd=('speed', 'mean'),
    media_hp=('hp', 'mean'),
    atk_max=('attack', 'max'),
    spd_max=('speed', 'max')
).round(2)

# Ordenar pelo ataque mÃ©dio (desc)
agr.sort_values('media_atk', ascending=False).head(10)
```

---

## 3) Agrupar por **mÃºltiplas colunas**

```python
# ğŸ¯ MÃ©dia de Attack por combinaÃ§Ã£o de (type_1, generation) â€“ ajuste o nome da coluna se existir 'generation'
col_gen = 'generation' if 'generation' in df_poke.columns else None

if col_gen:
    media_tipo_gen = df_poke.groupby(['type_1', col_gen])['attack'].mean().round(2)
    media_tipo_gen.head(10)
else:
    print("âš ï¸ Coluna 'generation' nÃ£o encontrada; pulando exemplo 3.")
```

---

## 4) Selecionar os **Top-N por grupo**

HÃ¡ vÃ¡rias estratÃ©gias. Duas clÃ¡ssicas:

### 4.1) Ordenar e pegar a cabeÃ§a de cada grupo

```python
# ğŸ¯ Top 5 PokÃ©mon por 'attack' dentro de cada type_1
# 1) Ordenamos por type_1 (asc) e attack (desc)
# 2) Em seguida usamos groupby + head(5) para pegar os 5 primeiros de cada grupo

top5_por_tipo = (
    df_poke
      .sort_values(['type_1','attack'], ascending=[True, False])
      .groupby('type_1')
      .head(5)[['name','type_1','attack','defense','speed']]
)
top5_por_tipo.head(15)
```

### 4.2) `nlargest` por grupo (quando focamos em **uma** mÃ©trica)

```python
# ğŸ¯ Top 3 por 'speed' em cada type_1
# EstratÃ©gia: aplicar um groupby + apply(nlargest)

top3_speed_tipo = (
    df_poke.groupby('type_1', group_keys=False)
           .apply(lambda g: g.nlargest(3, 'speed'))[['name','type_1','speed','attack']]
)
top3_speed_tipo.head(12)
```

---

## 5) FormataÃ§Ã£o e renomeaÃ§Ã£o de colunas resultantes

```python
# ğŸ¯ Deixar a tabela "linda" para ler: renomear, ordenar colunas e Ã­ndices

tabela = (
    df_poke.groupby('type_1')
           .agg(qtd=('name','count'),
                atk_med=('attack','mean'),
                def_med=('defense','mean'),
                spd_med=('speed','mean'),
                hp_med=('hp','mean'))
           .round(1)
           .sort_values(['atk_med','spd_med'], ascending=[False, False])
)
tabela.reset_index().head(10)
```

---

## 6) (Opcional) GrÃ¡ficos a partir de agregaÃ§Ãµes

> Sem estilizaÃ§Ã£o extra (mantendo o padrÃ£o das aulas): um grÃ¡fico simples ajuda a visualizar.

```python
import matplotlib.pyplot as plt

# ğŸ¯ Barras: quantidade de PokÃ©mon por tipo (Top 10)
contagem_tipo = df_poke['type_1'].value_counts().head(10)
ax = contagem_tipo.plot(kind='bar', figsize=(8,4))
ax.set_title('Top 10 tipos por quantidade de PokÃ©mon')
ax.set_xlabel('type_1')
ax.set_ylabel('Quantidade')
plt.tight_layout()
plt.show()
```

---

## 7) Aplicando `groupby()` no dataset de Escolas

```python
# ğŸ¯ 7.1 Contagem de escolas por municÃ­pio (Top 10)
if 'no_municipio' in df_escolas.columns:
    top10_mun = df_escolas['no_municipio'].value_counts().head(10)
    top10_mun

# ğŸ¯ 7.2 Agrupar por dependÃªncia administrativa (se existir)
if 'tp_dependencia' in df_escolas.columns:
    dep = df_escolas.groupby('tp_dependencia')['no_entidade'].count().sort_values(ascending=False)
    dep
```

---

## âœ… Checklist â€” Hoje vocÃª aprendeu

- `groupby()` por 1 ou N colunas.
- EstatÃ­sticas com `agg()` e agregaÃ§Ãµes mÃºltiplas.
- Ordenar, formatar e **escolher Top-N por grupo**.
- (Opcional) Gerar grÃ¡ficos simples a partir de agregaÃ§Ãµes.
- Aplicar a mesma lÃ³gica em datasets diferentes (PokÃ©mon e Escolas).

---

## ğŸ§ª Mini-Lab (para entregar no Classroom)

**Arquivo:** `UC22_Aula07_Pratica_SeuNome.ipynb`

### Parte 1 â€” PokÃ©mon

1. **MÃ©dias por tipo:** Crie uma tabela com `qtd`, `atk_med`, `def_med`, `spd_med`, `hp_med` por `type_1` (arredonde para 2 casas) e **ordene** por `atk_med` (desc) e `spd_med` (desc).
2. **Top 5 ataque por tipo:** Liste os **5 PokÃ©mon com maior `attack`** dentro de cada `type_1` (mostre `name`, `type_1`, `attack`, `speed`).
3. **Top 3 velocidade por tipo:** Usando `nlargest`, retorne os **3 mais rÃ¡pidos** por `type_1`.
4. **MÃ©dias por (type_1, generation)** â€“ se existir `generation`: mÃ©dia de `attack` e `speed` por par `(type_1, generation)`.

### Parte 2 â€” Escolas

1. **Top 10 municÃ­pios:** Mostre os 10 municÃ­pios com **maior nÃºmero de escolas**.
2. **DependÃªncia administrativa:** Agrupe por `tp_dependencia` e mostre a contagem de escolas (ordem desc).

> **Dica:** Use `.reset_index()` quando precisar transformar o Ã­ndice em coluna para ordenar/formatar.

---

## ğŸ§¯ Erros comuns

- **Esquecer colunas numÃ©ricas** em `agg()` â†’ confira `df.dtypes`.
- **Nome de coluna incorreto** â†’ revise com `df.columns`.
- **MultiIndex confuso** apÃ³s agrupar por vÃ¡rias colunas â†’ use `.reset_index()`.
- **Ordenar antes de `groupby().head(N)`** Ã© essencial para â€œTop-N por grupoâ€.
- **`nlargest` exige coluna numÃ©rica** e nÃ£o aceita valores `object`.

---

## ğŸ“ ConclusÃ£o

VocÃª aprendeu a **comparar grupos** e extrair **insights** com `groupby()`.
Isso nos permite responder perguntas como:

- Quais tipos tÃªm **maior ataque mÃ©dio**?
- Quais **PokÃ©mon mais rÃ¡pidos** em cada tipo?
- Quais municÃ­pios concentram **mais escolas**?

ğŸ”® **PrÃ³xima aula (8):** **OrdenaÃ§Ã£o com `sort_values()`** e **rankings globais**, conectando com os agrupamentos para criar **dashboards simples**.
