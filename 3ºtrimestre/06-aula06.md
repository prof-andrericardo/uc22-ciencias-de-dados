# ğŸ“˜ UC22 â€“ Aula 6 â€” Filtros Compostos (Pandas)

![Python](https://img.shields.io/badge/Python-3.11+-blue?logo=python)
![Pandas](https://img.shields.io/badge/Pandas-Filtros%20Compostos-green?logo=pandas)
![Google Colab](https://img.shields.io/badge/Google%20Colab-Notebook-yellow?logo=googlecolab)
![Tempo](https://img.shields.io/badge/Dura%C3%A7%C3%A3o-90%20min-red)
![N%C3%ADvel](https://img.shields.io/badge/N%C3%ADvel-Iniciante%E2%9E%9CIntermedi%C3%A1rio-purple)

ğŸ“ **Turma:** 3Âº Ano â€“ Ensino MÃ©dio TÃ©cnico em InformÃ¡tica
ğŸ“ **Tema:** CombinaÃ§Ã£o de condiÃ§Ãµes (E/OU/NÃƒO) para filtrar linhas em DataFrames
ğŸ **Ferramenta principal:** Google Colab

---

## âœ¨ Frase motivadora

> â€œFiltros compostos sÃ£o como estratÃ©gias de batalha: o segredo estÃ¡ na **combinaÃ§Ã£o**.â€ â€“ IAra âš”ï¸

---

## ğŸ¯ Objetivos de Aprendizagem

Ao final desta aula, vocÃª serÃ¡ capaz de:

- Combinar condiÃ§Ãµes com **AND (`&`)**, **OR (`|`)** e **NOT (`~`)** no Pandas.
- Usar **parÃªnteses** corretamente (ordem de avaliaÃ§Ã£o).
- Criar filtros robustos com `isin`, `between`, `str.contains` (com `na=False`).
- Alternar entre **sintaxe padrÃ£o** e **`.query()`** (com variÃ¡veis via `@`).
- Montar **mÃ¡scaras booleanas** reutilizÃ¡veis (cÃ³digo claro e legÃ­vel).

---

## ğŸ§  RevisÃ£o rÃ¡pida (Aula 5 â†’ Aula 6)

- Filtro **simples**: uma condiÃ§Ã£o (ex.: `df['attack'] > 100`).
- Filtros **compostos**: **duas ou mais condiÃ§Ãµes** combinadas (ex.: ataque alto **E** velocidade alta).
- Lembre-se: apÃ³s a leitura, **padronizamos nomes de colunas** para minÃºsculas e com `_`.

---

## ğŸ“‚ Preparando os dados (Google Drive)

> Use os mesmos arquivos das aulas anteriores, salvos em **Meu Drive/UC22**:
>
> - `pokemons_pokedex.csv`
> - `escolas_estaduais_censo_escolar_2023.csv`

```python
# ğŸ“‚ Conectando o Google Drive
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

# --- Caminhos (ajuste conforme sua pasta) ---
caminho_poke = "/content/drive/MyDrive/UC22/pokemons_pokedex.csv"
caminho_escolas = "/content/drive/MyDrive/UC22/escolas_estaduais_censo_escolar_2023.csv"

# --- Leitura ---
df_poke = pd.read_csv(caminho_poke, encoding="utf-8")
df_escolas = pd.read_csv(caminho_escolas, encoding="latin-1", sep=",")

# --- PadronizaÃ§Ã£o de nomes de colunas ---
df_poke.columns    = df_poke.columns.str.strip().str.lower().str.replace(" ", "_", regex=False)
df_escolas.columns = df_escolas.columns.str.strip().str.lower().str.replace(" ", "_", regex=False)

# --- Ajuste opcional de texto nas escolas ---
if "no_municipio" in df_escolas.columns:
    df_escolas["no_municipio"] = df_escolas["no_municipio"].astype(str).str.strip().str.upper()

print("âœ… PokÃ©mon:", df_poke.shape, "colunas:", len(df_poke.columns))
print("âœ… Escolas:", df_escolas.shape, "colunas:", len(df_escolas.columns))
```

---

## 1) Operadores lÃ³gicos no Pandas

- **AND:** `cond1 & cond2` â†’ ambas verdadeiras
- **OR:** `cond1 | cond2` â†’ pelo menos uma verdadeira
- **NOT:** `~cond` â†’ inverte True/False

âš ï¸ **Importante:** Sempre use **parÃªnteses** envolvendo cada condiÃ§Ã£o!

### Exemplo 1 â€” Ãgua **e** rÃ¡pida **e** defensiva moderada

```python
# ğŸ¯ Queremos: PokÃ©mon do tipo Ãgua com Speed > 70 E Defense >= 60
cond_tipo   = df_poke['type_1'] == 'Water'
cond_speed  = df_poke['speed'] > 70
cond_def    = df_poke['defense'] >= 60

mask = cond_tipo & cond_speed & cond_def  # AND entre as condiÃ§Ãµes
agua_rapida_defensiva = df_poke[mask][['name','type_1','defense','speed','attack']]

print("Qtd Ãgua & Speed>70 & Defense>=60:", agua_rapida_defensiva.shape[0])
agua_rapida_defensiva.head(10)
```

### Exemplo 2 â€” Fogo **ou** Gelo com ataque alto

```python
# ğŸ¯ Queremos: tipo Fogo OU tipo Gelo, com Attack > 100
cond_tipo  = (df_poke['type_1'] == 'Fire') | (df_poke['type_1'] == 'Ice')
cond_atk   = df_poke['attack'] > 100

mask = cond_tipo & cond_atk  # (Fogo OU Gelo) E ataque alto
fogo_ou_gelo_fortes = df_poke[mask][['name','type_1','attack','speed']]
fogo_ou_gelo_fortes.head(10)
```

### Exemplo 3 â€” NÃƒO lendÃ¡rio e muito veloz

```python
# ğŸ¯ Queremos: NÃƒO lendÃ¡rio (~) e Speed >= 120
# Se sua coluna de lendÃ¡rios tiver outro nome (ex.: 'legendary'), ajuste abaixo.
col_leg = 'legendary' if 'legendary' in df_poke.columns else None

if col_leg:
    mask = (~df_poke[col_leg]) & (df_poke['speed'] >= 120)
    nao_lendarios_rapidos = df_poke[mask][['name','type_1','speed', col_leg]]
    nao_lendarios_rapidos.head(10)
else:
    print("âš ï¸ Coluna de 'legendary' nÃ£o encontrada. Verifique df_poke.columns")
```

---

## 2) FunÃ§Ãµes Ãºteis para compor filtros

### 2.1 `isin` â€” pertence a uma lista

```python
# ğŸ¯ Tipos alvo: Electric, Psychic, Dragon
alvos = ['Electric','Psychic','Dragon']
mask  = df_poke['type_1'].isin(alvos)
df_poke[mask][['name','type_1','attack','speed']].head(10)
```

### 2.2 `between` â€” intervalo fechado \[min, max]

```python
# ğŸ¯ Attack entre 80 e 100 (inclusive), e Speed >= 80
mask = df_poke['attack'].between(80, 100) & (df_poke['speed'] >= 80)
df_poke[mask][['name','type_1','attack','speed']].head(10)
```

### 2.3 `str.contains` â€” texto (com seguranÃ§a contra NaN)

```python
# ğŸ¯ Nomes que contÃªm 'mega' (qualquer caso), sem quebrar em valores NaN
mask_nome = df_poke['name'].astype(str).str.contains('mega', case=False, na=False)
df_poke[mask_nome][['name','type_1','attack','defense','speed']].head(10)
```

---

## 3) `.query()` como alternativa mais legÃ­vel

- Escreva condiÃ§Ãµes como texto, semelhante a SQL.
- Use `@variavel` para passar listas/valores Python.

```python
# ğŸ¯ Exemplo com .query(): tipo em lista e ataque alto
tipos    = ['Fire','Ice']
ataque_corte = 100

resultado = df_poke.query("type_1 in @tipos and attack > @ataque_corte")[['name','type_1','attack','speed']]
resultado.head(10)
```

---

## 4) MÃ¡scaras booleanas reutilizÃ¡veis (cÃ³digo limpo)

> Em anÃ¡lises reais, a legibilidade Ã© essencial.

```python
# ğŸ¯ Time ofensivo: Attack > 110 E Speed > 95, NÃƒO lendÃ¡rio
col_leg = 'legendary' if 'legendary' in df_poke.columns else None

cond_ofensivo = (df_poke['attack'] > 110) & (df_poke['speed'] > 95)
cond_nao_leg  = ~df_poke[col_leg] if col_leg else True

mask_time = cond_ofensivo & cond_nao_leg
time_ofensivo = df_poke[mask_time].copy()

# Ordenamos para facilitar a escolha final
time_ofensivo = time_ofensivo.sort_values(by=['attack','speed'], ascending=False)
time_ofensivo[['name','type_1','attack','speed']].head(15)
```

---

## 5) Aplicando filtros compostos no dataset de Escolas (texto + OU/AND)

```python
# ğŸ¯ Ex.: escolas em CAMPINAS OU SANTOS, com dependÃªncia ESTADUAL
if {'no_municipio','tp_dependencia'}.issubset(df_escolas.columns):
    cidades = ['CAMPINAS','SANTOS']
    mask_cidade = df_escolas['no_municipio'].isin(cidades)
    mask_dep    = df_escolas['tp_dependencia'].astype(str).str.upper().str.contains('ESTADUAL', na=False)

    escolas_alvo = df_escolas[mask_cidade & mask_dep][['no_entidade','no_municipio','tp_dependencia']]
    print("Qtd escolas (Campinas ou Santos, Estadual):", escolas_alvo.shape[0])
    escolas_alvo.head(10)
else:
    print("âš ï¸ Verifique as colunas: no_municipio / tp_dependencia")
```

---

## âœ… Checklist do que vocÃª aprendeu hoje

- Combinar condiÃ§Ãµes com `&`, `|` e `~` usando **parÃªnteses**.
- Aplicar `isin`, `between`, `str.contains` para filtros sofisticados.
- Alternar entre sintaxe padrÃ£o e `.query()` com `@variavel`.
- Reutilizar **mÃ¡scaras booleanas** para legibilidade e manutenÃ§Ã£o.

---

## ğŸ§ª Mini-Lab (para entregar no Classroom)

**Arquivo:** `UC22_Aula06_Pratica_SeuNome.ipynb`

### Parte 1 â€” PokÃ©mon

1. **Defensores Ãgeis:** Liste PokÃ©mon com **defense â‰¥ 100** **E** **speed â‰¥ 90**. Mostre `name`, `type_1`, `defense`, `speed`, ordenando por `defense` (desc) e depois `speed` (desc).
2. **Ataque â€œna rÃ©guaâ€:** Selecione PokÃ©mon com `attack` **entre 80 e 100** (inclusive) **OU** que sejam do tipo **Electric**. Mostre `name`, `type_1`, `attack`.
3. **Filtro de texto seguro:** Encontre PokÃ©mon cujo `name` contenha â€œmegaâ€ (qualquer caso) **E** `attack > 100`. Mostre `name`, `type_1`, `attack`.
4. **Listas de tipos:** Usando `isin`, filtre PokÃ©mon cujo `type_1` pertenÃ§a a **\['Water','Grass','Ground']** **E** `hp â‰¥ 80`. Mostre `name`, `type_1`, `hp`.

### Parte 2 â€” Escolas

1. Selecione escolas em **CAMPINAS OU SANTOS** **E** com `tp_dependencia` contendo **â€œESTADUALâ€** (maiÃºsculas). Mostre `no_entidade`, `no_municipio`, `tp_dependencia`.
2. Se existir a coluna de **cÃ³digo** (ex.: `co_entidade`), filtre escolas com cÃ³digo **entre 35000000 e 35099999** **E** `no_municipio == 'SÃƒO PAULO'`. Mostre `co_entidade`, `no_entidade`, `no_municipio`.

> **Dica:** Crie **mÃ¡scaras nomeadas** (ex.: `mask_cidade`, `mask_dep`) para deixar o cÃ³digo claro.

---

## ğŸ§¯ Erros comuns (e como evitar)

- **Faltam parÃªnteses:** `cond1 & cond2` â†’ **sempre** `(cond1) & (cond2)`.
- **Usar `and`/`or`/`not`:** Em Pandas, use `&`, `|`, `~` (os do Python lÃ³gico nÃ£o funcionam entre Series).
- **`KeyError`**: nome de coluna errado â†’ confira `df.columns`.
- **`str.contains` com NaN:** use `na=False` e `astype(str)` para evitar erros.
- **Tipos mistos:** ao comparar nÃºmeros, garanta tipo numÃ©rico com `pd.to_numeric()` se necessÃ¡rio.
- **Filtro vazio:** nÃ£o Ã© erro; significa â€œnenhuma linha atende Ã s condiÃ§Ãµesâ€.

---

## ğŸ“ ConclusÃ£o

Hoje vocÃª aprendeu a **combinar condiÃ§Ãµes** e criar filtros poderosos e **legÃ­veis**.
Isso Ã© o alicerce para anÃ¡lises mais profundas, como:

- Encontrar **perfis** (ofensivo, defensivo, equilibrado).
- Ver padrÃµes entre grupos de cidades, tipos ou faixas de valores.

ğŸ”® **Na prÃ³xima aula (7):** vamos para **Agrupamentos com `groupby()`** â€” mÃ©dias por tipo, contagens por categoria, top-N por grupoâ€¦ o coraÃ§Ã£o das anÃ¡lises comparativas!

---
